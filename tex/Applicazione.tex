\chapter{L'Applicazione}
	Per avere un confronto più significativo, il tutore aziendale ci ha proposto
	la realizzazione di un'applicazione che interagisse, in maniera sostanziale,
	con le funzionalità offerte dal dispositivo in modo da poter valutare meglio
	la potenzialità delle API offerte dai due frame\-work in analisi.
	
	L'applicazione che ci è stata commissionata permette all'utente di segnalare 
	problemi di degrado ambientale con immagini e testo georeferenziati.
	In particolare l'applicazione inizialmente doveva permette all'utente di:
	\begin{itemize}
		\item registrarsi nel sistema al primo avvio e di autenticarsi in quelli
		      successivi;
		\item visualizzare su una mappa le proprie segnalazioni e quelle inviate
		      degli altri utenti;
		\item comporre e inviare su un server una nuova segnalazione
		      georeferenziata inserendo una descrizione testuale e una foto del
		      degrado scattata con il dispositivo;
		\item visualizzare una lista riassuntiva delle proprie segnalazioni
		      inviate;
		\item scegliere un segnalazione e visualizzarne i dettagli.
	\end{itemize}
	Durante la fase di sviluppo però, in occasione della revisione periodica del
	nostro lavoro svolto, sono state richieste nuove funzionalità aggiuntive; in
	particolare ci è stato chiesto di aggiungere:
	\begin{itemize}
		\item una lista generale che mostrasse le ultime segnalazioni inviate da
		      qualsiasi utente;
		\item un meccanismo di salvataggio locale delle proprie segnalazioni e
		      di tutte quelle visualizzate in dettaglio permettendo così
		      all'applicazione un parziale funzionamento anche in assenza di
		      connessione Internet;
		\item la possibilità di ritrovare sulla mappa una segnalazione partendo
		      dalla visualizzazione dei suoi dettagli.
	\end{itemize}
	
	La registrazione e l'autenticazione dell'utente sul server doveva avvenire 
	utilizzando come credenziali di accesso il codice IMEI o il numero di
	telefono, che dovevano essere letti automaticamente dall'applicazione,
	senza necessità d'interazione con l'utente. Abbiamo però deciso, inoltre, di
	dare all'utente che si sta registrando la possibilità di scegliersi un
	``nickname'' univoco\footnote{Il controllo dell'univocità è stato demandato
	al lato server e verrà descritto più in dettaglio nella sezione apposita.}
	e di inserire il proprio indirizzo e-mail con l'idea di aggiungere,
	successivamente, queste informazioni in tutte le sue segnalazioni; in questo
	modo un altro utente che visualizza una certa segnalazione può vedere chi
	l'ha realizzata e, se vuole, sarà in grado di contattarlo tramite posta
	elettronica. Per semplicità abbiamo deciso che una volta scelto il nickname
	questo sarà permanente, diversamente abbiamo aggiunto nell'applicazione una
	schermata tramite la quale sarà possibile aggiornare il proprio indirizzo
	e-mail.
	
	L'applicazione, come ovvio, sarà composta di una parte client e di una parte
	server. Il lato client, che risiederà sul dispositivo mobile, è la parte dove
	si concentrano i nostri studi e dove
	mostreremo come sono state implementate le funzionalità richieste
	utilizzando i due frame\-work presi in esame. Il lato server risiederà
	su una macchina dedicata e per quanto riguarda la sua analisi, non
	essendo scopo di questa attività di tirocinio, ne daremo solo una
	semplice descrizione sul funzionamento e sulle tecnologie
	impiegate per realizzarlo.
	
	\section{Lato Server}
		Lo scopo principale del lato server di questa applicazione è quello di
		gestire un database che andrà a contenere tutte le segnalazioni inviate
		dagli utenti attraverso il dispositivo mobile. Il
		database dovrà essere in grado di rispondere a query riguardanti
		certamente le coordinate geografiche, ma anche i nickname e la data e
		ora delle varie segnalazioni. Un secondo compito importante che dovrà
		svolgere, sarà quello di gestire le identità dei diversi utenti e di
		controllare l'univocità del nickname utilizzato in fase di
		registrazione.
		
		Una caratteristica in più che non era richiesta ma che ci sembrava
		opportuno avere era l'indipendenza della realizzazione del server
		rispetto ai due frame\-work utilizzati nell'implementare il lato client.
		In questo modo entrambe le implementazioni del lato client avrebbero
		dialogato con la stessa implementazione del lato server.
		
		Per la realizzazione di tutto questo, dopo una fase di ricerca, abbiamo
		mirato a due prodotti open source vista la loro semplicità d'uso:
		Apache CouchDB\texttrademark{} e Node.js.
		\begin{description}
			\item[Apache CouchDB\texttrademark{}] è un DBMS (database-management
				system) doc\-u\-ment-ori\-ented accessibile mediante API RESTful\footnote{Il termine è usato
				per descrivere un'interfaccia che trasmette dati su HTTP. Per una
				descrizione più esaustiva vedere
				\url{http://it.wikipedia.org/wiki/Representational_State_Transfer}}
				con scambio di dati in formato \js{} Object Notation (JSON). Questa
				caratteristica permette di eseguire facilmente operazioni sul database
				indipendentemente dal linguaggio usato per realizzare l'applicazione.
				
				Un database document-oriented è composto da una serie di documenti
				``auto-contenenti'', questo significa che il documento in
				questione è memorizzato nel documento stesso anziché in una tabella
				come avviene nei database relazionali. Infatti in Apache CouchDB\texttrademark{}
				non esistono tabelle, righe, colonne e relazioni tra i
				documenti e quindi aggiungere o rimuovere un nuovo
				campo ad un documento non influisce negativamente sugli altri.
				
				Ogni documento è rappresentato in una struttura JSON che può
				contenere tipi di dato, come stringhe di testo, numeri e valori
				booleani; inoltre Apache CouchDB\texttrademark{} permette
				di allegare file multimediali ad ogni documento quindi nella sua
				definizione JSON sarà presente anche un riferimento a tale allegato. 
				Questa caratteristica ci ha permesso di inserire sia l'immagine che
				i dati di una segnalazione all'interno di un singolo documento.
				
				Nella sua versione pura, CouchDB non permette di eseguire interrogazioni 
				spaziali basate su coordinate geografiche, per sopperire a questa
				mancanza si è dovuto ricorrere all'utilizzo dell'apposita estensione
				GeoCouch\footnote{La documentazione 
				è disponibile sul sito \url{https://github.com/couchbase/geocouch/}}.
			\item[Node.js] è una piattaforma realizzata sul motore \js{} V8 di
				Google Chrome per la realizzazione facile e veloce di
				applicazioni di rete. La potenza di questa piattaforma è anche
				nel fatto che è supportata da una enorme quantità di moduli
				che permettono di realizzare con poco codice applicazioni piuttosto
				complesse; in più, come Apache CouchDB\texttrademark{}, tutto 
				questo è open source. Node.js è stato usato per creare un
				semplice web server che, comunicando col database Apache CouchDB\texttrademark{}
				attraverso le proprie API HTTP, gestisse le richieste di
				registrazione provenienti da nuovi utenti.
		\end{description}
		
		Apache CouchDB\texttrademark{} è stato quindi configurato per gestire e
		memorizzare l'insieme degli utenti e delle segnalazioni.
		Ogni documento rappresentante una segnalazione è composto dai campi:
		\begin{description}
			\item[Titolo] Stringa di poche parole per descrivere la segnalazione.
				Questo valore verrà poi visualizzato nelle liste di segnalazioni
				sul lato client.
			\item[Descrizione] Una descrizione testuale più dettagliata sul
				fenomeno di degrado segnalato. Questo valore verrà mostrato sul
				lato client solo tra i dettagli di una segnalazione.
			\item[Data] Stringa testuale che indica la data e l'ora dell'istante
				in cui la segnalazione è stata creata dall'utente. Anche questo
				valore sarà mostrato solo tra i dettagli.
			\item[Coordinate] Valore composto da due campi che contengono la
				latitudine nord e la longitudine est della posizione geografica
				in cui l'utente di trovava quando ha creato la segnalazione. Anche
				la posizione geografica verrà mostrata solo tra i dettagli della
				segnalazione.
			\item[Immagine] Una foto scattata dal dispositivo usata	per
				documentare il degrado individuato che verrà mostrata all'utente
				solo nella schermata dei dettagli della relativa segnalazione.
			\item[UserId] Identificatore unico relativo all'utente che ha creato
				questa segnalazione. Questo valore è necessario visto che in
				Apache CouchDB\texttrademark{}, non essendo un database relazionale,
				non è possibile in alcun altro modo mettere in relazione un utente con
				tutte le sue segnalazioni. Con questo accorgimento si sta di fatto
				creando tale relazione in modo che, una volta scaricate le
				informazioni su una segnalazione, sarà possibile eseguire una
				seconda query sul database degli utenti per ottenere i valori
				di nickname e mail dell'utente che ha creato quella segnalazione.
			\item[Id] Questo valore è univoco ed è scelto automaticamente da
				Apache CouchDB\texttrademark{}, nel momento del
				salvataggio della segnalazione sul server.
		\end{description}
		
		Per quanto riguarda la rappresentazione di un utente bisogna approfondire
		un po' più l'argomento. Apache CouchDB\texttrademark{} fornisce un
		particolare database di nome \verb|_users| in cui, ogni documento 
		rappresenta un utente e deve contenere i campi \texttt{name} e \texttt{password}, i cui
		rispettivi valori saranno poi utilizzati come credenziali di
		autenticazione da inserire nelle richieste HTTP per consentire
		all'utente operazioni sui DB contenuti nel server\footnote{
		Apache CouchDB\texttrademark{} permette una gestione delle utenze molto
		più accurata; per esempio è possibile riservare l'accesso ad un DB ad un
		particolare gruppo di utenti.}. Oltre ai suddetti campi obbligatori è
		possibile definirne altri pubblici, ovvero campi che al contrario di
		\texttt{name} e \texttt{password} saranno visibili a qualsiasi altro utente.
		Nel nostro caso abbiamo inserito solo due nuovi campi pubblici:
		\begin{description}
			\item[nickname] Un nome identificativo scelto dall'utente in fase di
				registrazione e mostrato poi nei dettagli di tutte le sue segnalazioni.
			\item[mail] Indirizzo di posta elettronica dell'utente mostrato anche questo
				nei dettagli di tutte le sue segnalazioni.
		\end{description}
		
		L'aggiunta di nuovi utenti nel database \verb|_users| deve essere fatta
		attraverso opportuni messaggi HTTP nei quali occorre essere autenticati
		come amministratori del server\footnote{Questo particolare utente viene
		definito in fase di configurazione del server Apache CouchDB\texttrademark{}}.
		Nasce qui il problema di come far registrare sul server nuovi utenti
		direttamente dal lato client dell'applicazione. Potevamo, a questo punto,
		scegliere d'inserire nel codice del lato client le credenziali
		d'amministratore usandole soltanto nelle richieste HTTP per la registrazione
		di un nuovo utente.	Successivamente il dispositivo mobile avrebbe continuato a
		comunicare con il server usando le credenziali del nuovo utente. Ovviamente
		questa soluzione avrebbe permesso a chiunque avesse accesso al codice
		sorgente dell'applicazione di ottenere nome utente e password dell'amministratore.
		Abbiamo quindi deciso di realizzare un semplice web server implementato
		con Node.js che lavori a fianco di Apache CouchDB\texttrademark{}
		(vedi fig.~\ref{fig:latoserver}) con il
		compito: di ascoltare richieste di registrazione provenienti dal lato
		client, di inoltrarle al DBMS aggiungendovi le credenziali di amministratore
		e di controllare che il \texttt{nickname} scelto dall'utente non sia già
		stato usato da un altro. Così facendo le credenziali di amministratore
		del DBMS sono contenute all'interno del web server Node.js e non sono più
		reperibili direttamente dal codice del lato client. 
		
		\begin{figure}[h]
			\centering
			\includegraphics[keepaspectratio=true, width=0.95\textwidth]{lato-server}
			\caption{
				Architettura del lato server dell'applicazione.
			}
			\label{fig:latoserver}
		\end{figure}
		
		Fin ora abbiamo detto che nelle varie richieste HTTP devo essere presenti
		le credenziali di autenticazione. Apache CouchDB\texttrademark{} fornisce
		vari meccanismi di autenticazione tra cui Basic Access Authentication\footnote{
		Schema di autenticazione definito per HTTP nella RFC2617 consultabile al'indirizzo
		\url{https://tools.ietf.org/html/rfc2617\#section-2}.}
		che abbiamo scelto di utilizzare per la sua semplicità. In questo modo il
		passaggio delle credenziali di accesso da client a server avviene attraverso 
		il campo header \texttt{Authorization} inserito nel messaggio di richiesta HTTP 
		come nell'esempio 
		\begin{lstlisting}[language=http]
	GET index.html HTTP/1.1
	Host: www.someserver.com
	Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQK
	 ...
		\end{lstlisting}
		dove \texttt{dXNlcm5hbWU6cGFzc3dvcmQK} è la stringa ``name:password'' 
		codificata in base64\footnote{Per una completa specifica del sistema di
		codifica/decodifica base64 consultare la RFC4648 disponibili all'indirizzo
		\url{http://www.rfc-editor.org/pdfrfc/rfc4648.txt.pdf}}.
		Questo tipo di autenticazione non prevede protezione per le credenziali 
		trasmesse; come visto esse vengono banalmente codificate in base64 ma non 
		criptate. Per cui l'uso di questo tipo di 
		autenticazione andrebbe fatto assieme ad un sistema di sicurezza esterno 
		come SSL\citep{Web:RFC2617}. CouchDB permette l'uso del protocollo HTTPS, 
		che però non abbiamo adottato dato che lo scopo del tirocinio non era quello di focalizzarsi 
		sulla sicurezza.
	
	
	\section{Lato Client}
		In questa sezione prenderemo in esame le varie funzionalità fornite
		dall'applicazione come pretesto per mostrare come si sono
		comportati i due framework quando abbiamo cercato di realizzarle. Non ci addentreremo
		nei dettagli di carattere algoritmico nelle soluzioni dei vari problemi ma,
		piuttosto, mostreremo quali strumenti \tisdk{} e \pg{} ci hanno fornito
		per poterli risolvere.
		
		\subsection{Cominicare con il lato server}
			Sia con \tisdk{} che con \pg{} il linguaggio principalmente utilizzato,
			come abbiamo già detto, è \js{} e per questo motivo c'è stato il bisogno
			di realizzare una libreria fatta su misura che ci permettesse di generare
			i giusti messaggi HTTP da inviare al server. Ora, \tisdk{} ha la propria
			libreria \texttt{Titanium.Network} che permette di istanziare un
			particolare oggetto	\texttt{Titanium.Network.HTTPClient} con il
			quale è possibile comporre ogni genere di richiesta HTTP. \pg{}
			invece non fornisce nulla di tutto ciò e quindi abbiamo dovuto far
			ricorso alle funzionalità AJAX di \jq{} fornito dal framework
			\kendomob{}\footnote{Ricordiamo che \kendomob{}	è basato proprio su
			\jq{} e fornisce quindi tutte le sue funzionalità.}. Alla luce di
			questi fatti è stata definita un unica interfaccia di funzioni \js{}
			e ne sono state realizzate due diverse implementazioni: una
			fruttando gli oggetti HTTPClient di \tisdk{} e l'altra basandoci
			sulla funzione \verb|$.ajax(...)| di \jq{}\footnote{Maggiori
			dettagli sull'uso di HTTPClinet e \texttt{\$.ajax(...)} sono
			disponibili nelle rispettive documentazioni online:\\
			\url{http://docs.appcelerator.com/titanium/latest/\#!/api/Titanium.Network.HTTPClient}
			e\\ \url{http://api.jquery.com/jQuery.ajax/}.}.
			È importante far notare
			che, sia HTTPClient che \verb|$.ajax(...)| implementano un sistema
			di comunicazione asincrono, ciò significa che una volta inviate le
			richieste HTTP, il programma continuerà ad essere eseguito in attesa
			che dal server tornino le relative risposte; a questo punto verrà
			eseguito l'opportuno codice che gestirà tale evento.
			
		
		
		
		
		
