\chapter{L'Applicazione}
	Per avere un confronto più significativo, il tutore aziendale ci ha proposto
	la realizzazione di un'applicazione che interagisse, in maniera sostanziale,
	con le funzionalità offerte dal dispositivo in modo da poter valutare meglio
	la potenzialità delle API offerte dai due frame\-work in analisi.
	
	L'applicazione che ci è stata commissionata permette all'utente di segnalare 
	problemi di degrado ambientale con immagini e testo georeferenziati.
	In particolare l'applicazione inizialmente doveva permette all'utente di:
	\begin{itemize}
		\item registrarsi nel sistema al primo avvio e di autenticarsi in quelli
		      successivi;
		\item visualizzare su una mappa le proprie segnalazioni e quelle inviate
		      degli altri utenti;
		\item comporre e inviare su un server una nuova segnalazione
		      georeferenziata inserendo una descrizione testuale e una foto del
		      degrado scattata con il dispositivo;
		\item visualizzare una lista riassuntiva delle proprie segnalazioni
		      inviate;
		\item scegliere un segnalazione e visualizzarne i dettagli.
	\end{itemize}
	Durante la fase di sviluppo però, in occasione della revisione periodica del
	nostro lavoro svolto, sono state richieste nuove funzionalità aggiuntive; in
	particolare ci è stato chiesto di aggiungere:
	\begin{itemize}
		\item una lista generale che mostrasse le ultime segnalazioni inviate da
		      qualsiasi utente;
		\item un meccanismo di salvataggio locale delle proprie segnalazioni e
		      di tutte quelle visualizzate in dettaglio permettendo così
		      all'applicazione un parziale funzionamento anche in assenza di
		      connessione Internet;
		\item la possibilità di ritrovare sulla mappa una segnalazione partendo
		      dalla visualizzazione dei suoi dettagli.
	\end{itemize}
	
	\noindent La registrazione e l'autenticazione dell'utente sul server doveva avvenire 
	utilizzando come credenziali di accesso il codice IMEI o il numero di
	telefono, che dovevano essere letti automaticamente dall'applicazione,
	senza necessità d'interazione con l'utente. Abbiamo però deciso, inoltre, di
	dare all'utente che si sta registrando la possibilità di scegliersi un
	``nickname'' univoco\footnote{Il controllo dell'univocità è stato demandato
	al lato server e verrà descritto più in dettaglio nella sezione apposita.}
	e di inserire il proprio indirizzo e-mail con l'idea di aggiungere,
	successivamente, queste informazioni in tutte le sue segnalazioni; in questo
	modo un altro utente che visualizza una certa segnalazione può vedere chi
	l'ha realizzata e, se vuole, sarà in grado di contattarlo tramite posta
	elettronica. Per semplicità abbiamo deciso che una volta scelto il nickname
	questo sarà permanente, diversamente abbiamo aggiunto nell'applicazione una
	schermata tramite la quale sarà possibile aggiornare il proprio indirizzo
	e-mail.
	
	L'applicazione, come ovvio, sarà composta di una parte client e di una parte
	server. Il lato client, che risiederà sul dispositivo mobile, è la parte dove
	si concentrano i nostri studi e dove
	mostreremo come sono state implementate le funzionalità richieste
	utilizzando i due frame\-work presi in esame. Il lato server risiederà
	su una macchina dedicata e per quanto riguarda la sua analisi, non
	essendo scopo di questa attività di tirocinio, ne daremo solo una
	semplice descrizione sul funzionamento e sulle tecnologie
	impiegate per realizzarlo.
	
	\section{Lato Server}
		Lo scopo principale del lato server di questa applicazione è quello di
		gestire un database che andrà a contenere tutte le segnalazioni inviate
		dagli utenti attraverso il dispositivo mobile. Il
		database dovrà essere in grado di rispondere a query riguardanti
		certamente le coordinate geografiche, ma anche i nickname e la data e
		ora delle varie segnalazioni. Un secondo compito importante che dovrà
		svolgere, sarà quello di gestire le identità dei diversi utenti e di
		controllare l'univocità del nickname utilizzato in fase di
		registrazione.
		
		Una caratteristica in più che non era richiesta ma che ci sembrava
		opportuno avere era l'indipendenza della realizzazione del server
		rispetto ai due frame\-work utilizzati nell'implementare il lato client.
		In questo modo entrambe le implementazioni del lato client avrebbero
		dialogato con la stessa implementazione del lato server.
		
		Per la realizzazione di tutto questo, dopo una fase di ricerca, abbiamo
		mirato a due prodotti open source vista la loro semplicità d'uso:
		Apache CouchDB\texttrademark{} e Node.js.
		\begin{description}
			\item[Apache CouchDB\texttrademark{}] è un DBMS (database-management
				system) doc\-u\-ment-ori\-ented accessibile mediante API RESTful\footnote{Il termine è usato
				per descrivere un'interfaccia che trasmette dati su HTTP. Per una
				descrizione più esaustiva vedere
				\url{http://it.wikipedia.org/wiki/Representational_State_Transfer}}
				con scambio di dati in formato \js{} Object Notation (JSON). Questa
				caratteristica permette di eseguire facilmente operazioni sul database
				indipendentemente dal linguaggio usato per realizzare l'applicazione.
				
				Un database document-oriented è composto da una serie di documenti
				``auto-contenenti'', questo significa che il documento in
				questione è memorizzato nel documento stesso anziché in una tabella
				come avviene nei database relazionali. Infatti in Apache CouchDB\texttrademark{}
				non esistono tabelle, righe, colonne e relazioni tra i
				documenti e quindi aggiungere o rimuovere un nuovo
				campo ad un documento non influisce negativamente sugli altri.
				
				Ogni documento è rappresentato in una struttura JSON che può
				contenere tipi di dato, come stringhe di testo, numeri e valori
				booleani; inoltre Apache CouchDB\texttrademark{} permette
				di allegare file multimediali ad ogni documento quindi nella sua
				definizione JSON sarà presente anche un riferimento a tale allegato. 
				Questa caratteristica ci ha permesso di inserire sia l'immagine che
				i dati di una segnalazione all'interno di un singolo documento.
				
				Nella sua versione pura, CouchDB non permette di eseguire interrogazioni 
				spaziali basate su coordinate geografiche, per sopperire a questa
				mancanza si è dovuto ricorrere all'utilizzo dell'apposita estensione
				GeoCouch\footnote{La documentazione 
				è disponibile sul sito \url{https://github.com/couchbase/geocouch/}}.
			\item[Node.js] è una piattaforma realizzata sul motore \js{} V8 di
				Google Chrome per la realizzazione facile e veloce di
				applicazioni di rete. La potenza di questa piattaforma è anche
				nel fatto che è supportata da una enorme quantità di moduli
				che permettono di realizzare con poco codice applicazioni piuttosto
				complesse; in più, come Apache CouchDB\texttrademark{}, tutto 
				questo è open source. Node.js è stato usato per creare un
				semplice web server che, comunicando col database Apache CouchDB\texttrademark{}
				attraverso le proprie API HTTP, gestisse le richieste di
				registrazione provenienti da nuovi utenti.
		\end{description}
		
		\noindent Apache CouchDB\texttrademark{} è stato quindi configurato per gestire e
		memorizzare l'insieme degli utenti e delle segnalazioni.
		Ogni documento rappresentante una segnalazione è composto dai campi:
		\begin{description}
			\item[Titolo] Stringa di poche parole per descrivere la segnalazione.
				Questo valore verrà poi visualizzato nelle liste di segnalazioni
				sul lato client.
			\item[Descrizione] Una descrizione testuale più dettagliata sul
				fenomeno di degrado segnalato. Questo valore verrà mostrato sul
				lato client solo tra i dettagli di una segnalazione.
			\item[Data] Stringa testuale che indica la data e l'ora dell'istante
				in cui la segnalazione è stata creata dall'utente. Anche questo
				valore sarà mostrato solo tra i dettagli.
			\item[Coordinate] Valore composto da due campi che contengono la
				latitudine nord e la longitudine est della posizione geografica
				in cui l'utente di trovava quando ha creato la segnalazione. Anche
				la posizione geografica verrà mostrata solo tra i dettagli della
				segnalazione.
			\item[Immagine] Una foto scattata dal dispositivo usata	per
				documentare il degrado individuato che verrà mostrata all'utente
				solo nella schermata dei dettagli della relativa segnalazione.
			\item[UserId] Identificatore unico relativo all'utente che ha creato
				questa segnalazione. Questo valore è necessario visto che in
				Apache CouchDB\texttrademark{}, non essendo un database relazionale,
				non è possibile in alcun altro modo mettere in relazione un utente con
				tutte le sue segnalazioni. Con questo accorgimento si sta di fatto
				creando tale relazione in modo che, una volta scaricate le
				informazioni su una segnalazione, sarà possibile eseguire una
				seconda query sul database degli utenti per ottenere i valori
				di nickname e mail dell'utente che ha creato quella segnalazione.
			\item[Id] Questo valore è univoco ed è scelto automaticamente da
				Apache CouchDB\texttrademark{}, nel momento del
				salvataggio della segnalazione sul server.
		\end{description}
		
		\noindent Per quanto riguarda la rappresentazione di un utente bisogna approfondire
		un po' più l'argomento. Apache CouchDB\texttrademark{} fornisce un
		particolare database di nome \verb|_users| in cui, ogni documento 
		rappresenta un utente e deve contenere i campi \texttt{name} e \texttt{password}, i cui
		rispettivi valori saranno poi utilizzati come credenziali di
		autenticazione da inserire nelle richieste HTTP per consentire
		all'utente operazioni sui DB contenuti nel server\footnote{
		Apache CouchDB\texttrademark{} permette una gestione delle utenze molto
		più accurata; per esempio è possibile riservare l'accesso ad un DB ad un
		particolare gruppo di utenti.}. Oltre ai suddetti campi obbligatori è
		possibile definirne altri pubblici, ovvero campi che al contrario di
		\texttt{name} e \texttt{password} saranno visibili a qualsiasi altro utente.
		Nel nostro caso abbiamo inserito solo due nuovi campi pubblici:
		\begin{description}
			\item[nickname] Un nome identificativo scelto dall'utente in fase di
				registrazione e mostrato poi nei dettagli di tutte le sue segnalazioni.
			\item[mail] Indirizzo di posta elettronica dell'utente mostrato anche questo
				nei dettagli di tutte le sue segnalazioni.
		\end{description}
		
		\noindent L'aggiunta di nuovi utenti nel database \verb|_users| deve essere fatta
		attraverso opportuni messaggi HTTP nei quali occorre essere autenticati
		come amministratori del server\footnote{Questo particolare utente viene
		definito in fase di configurazione del server Apache CouchDB\texttrademark{}}.
		Nasce qui il problema di come far registrare sul server nuovi utenti
		direttamente dal lato client dell'applicazione. Potevamo, a questo punto,
		scegliere d'inserire nel codice del lato client le credenziali
		d'amministratore usandole soltanto nelle richieste HTTP per la registrazione
		di un nuovo utente.	Successivamente il dispositivo mobile avrebbe continuato a
		comunicare con il server usando le credenziali del nuovo utente. Ovviamente
		questa soluzione avrebbe permesso a chiunque avesse accesso al codice
		sorgente dell'applicazione di ottenere nome utente e password dell'amministratore.
		Abbiamo quindi deciso di realizzare un semplice web server implementato
		con Node.js che lavori a fianco di Apache CouchDB\texttrademark{}
		(vedi fig.~\ref{fig:latoserver}) con il
		compito: di ascoltare richieste di registrazione provenienti dal lato
		client, di inoltrarle al DBMS aggiungendovi le credenziali di amministratore
		e di controllare che il \texttt{nickname} scelto dall'utente non sia già
		stato usato da un altro. Così facendo le credenziali di amministratore
		del DBMS sono contenute all'interno del web server Node.js e non sono più
		reperibili direttamente dal codice del lato client. 
		
		\begin{figure}[h]
			\centering
			\includegraphics[keepaspectratio=true, width=0.95\textwidth]{lato-server}
			\caption{
				Architettura del lato server dell'applicazione.
			}
			\label{fig:latoserver}
		\end{figure}
		
		Fin ora abbiamo detto che nelle varie richieste HTTP devo essere presenti
		le credenziali di autenticazione. Apache CouchDB\texttrademark{} fornisce
		vari meccanismi di autenticazione tra cui Basic Access Authentication\footnote{
		Schema di autenticazione definito per HTTP nella RFC2617 consultabile al'indirizzo
		\url{https://tools.ietf.org/html/rfc2617\#section-2}.}
		che abbiamo scelto di utilizzare per la sua semplicità. In questo modo il
		passaggio delle credenziali di accesso da client a server avviene attraverso 
		il campo header \texttt{Authorization} inserito nel messaggio di richiesta HTTP 
		come nell'esempio 
		\begin{lstlisting}[language=http]
	GET index.html HTTP/1.1
	Host: www.someserver.com
	Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQK
	 ...
		\end{lstlisting}
		dove \texttt{dXNlcm5hbWU6cGFzc3dvcmQK} è la stringa ``name:password'' 
		codificata in base64\footnote{Per una completa specifica del sistema di
		codifica/decodifica base64 consultare la RFC4648 disponibili all'indirizzo
		\url{http://www.rfc-editor.org/pdfrfc/rfc4648.txt.pdf}}.
		Questo tipo di autenticazione non prevede protezione per le credenziali 
		trasmesse; come visto esse vengono banalmente codificate in base64 ma non 
		criptate. Per cui l'uso di questo tipo di 
		autenticazione andrebbe fatto assieme ad un sistema di sicurezza esterno 
		come SSL\citep{Web:RFC2617}. CouchDB permette l'uso del protocollo HTTPS, 
		che però non abbiamo adottato dato che lo scopo del tirocinio non era quello di focalizzarsi 
		sulla sicurezza.
	
	
	\section{Lato Client}
		In questa sezione prenderemo in esame le varie funzionalità fornite
		dall'applicazione come pretesto per mostrare come si sono
		comportati i due framework. Non ci addentreremo
		nei dettagli di carattere algoritmico nelle soluzioni dei vari problemi ma,
		piuttosto, mostreremo quali strumenti ci hanno fornito \tisdk{} e \pg{}
		per poterli risolvere.
		
		\subsection{Struttura}
			Descriviamo ora la struttura generale dell'applicazione dal punto 
			di vista grafico.
			Abbiamo cercato di fornire lo stesso aspetto alle due versioni 
			dell'applicazione. E' interessante vedere come i due framework hanno risposto 
			alle nostre esigenze. Prendendo spunto da applicazioni native come 
			gmail e facebook l'idea è stata quella di avere una barra di intestazione 
			nella parte alta dello schermo, che contenesse un pulsante in grado di 
			far apparire un menù dal quale accedere alle varie schermate dell'applicazione.
			Viste le funzionalità richieste dall'applicazione abbiamo creato schermate 
			differenti per:
			\begin{enumerate} 
				\item visualizzare la mappa delle segnalazioni 
				\item visualizzare la lista delle segnalazioni fatte dall'utente
				\item visualizzare la lista delle ultime segnalazioni fatte da tutti gli utenti
				\item comporre ed inviare la segnalazione
				\item effettuare la registrazione e/o modificare l'indirizzo mail registrato.
				\item visualizzare i dettagli di una segnalazione
			\end{enumerate}
			
			I due framework approcciano in maniera differente il concetto di schermata: 
			in \kendomob{} le schermate vanno inserite nel body dello stesso 
			file HTML, tramite div decorati con l'attributo data-role=view, la 
			navigazione tra di esse avviene attraverso le ancore come nelle normali 
			pagine web si naviga all'interno dello stesso documento; Titanium invece 
			permette due modi diversi di definire una schermata: la view e la window.
			Una view deve essere necessariamente contenuta in una window, nel linguaggio 
			del web una window Titanium è paragonabile ad una pagina web. Mentre le view 
			sono analoghe ai div. Un'applicazione potrebbe essere costituita da un'unica 
			window con tante view (che sarebbe la stessa tecnica usata con \kendomob{}) 
			dando l'effetto appunto di essere composta da schermate differenti, oppure 
			può essere composta da tante window. La differenza si ha nel fatto che 
			le window hanno contesti di esecuzione diversi l'una dall'altra al contrario 
			delle view che condividono quello della window che le contiene.
			Personalmente abbiamo scelto di implementare le schermate 1,2,3 come 
			view appartenenti alla stessa window e le 4, 5, 6 come window differenti, 
			questo ha facilitato la navigazione tra le varie schermate, in quanto 
			il passaggio da una view all'altra non è così semplice in \tisdk{} come 
			lo è invece in \kendomob{}.
			
			Per la barra di intestazione ed il menù di navigazione abbiamo trovato 
			differenze sostanziali tra i due framework.
			Partiamo con \kendomob{}
			Innanzitutto esso offre un particolare elemento grafico chiamato drawer, 
			ovvero un bottone che se premuto porta all'apertura di 
			una lista che si espande partendo dalla sinistra dello schermo e che 
			si va a sovrapporre al contenuto della schermata stessa.
			Ogni schermata può essere suddivisa in un intestazione e un corpo, 
			con l'effetto che l'intestazione apparirà come una barra nella parte alta 
			dello schermo. Per essere più precisi la sua posizione dipende dalla
			piattaforma: di default su iOS la posizione è in alto, mentre per Android 
			è in basso, ma, attraverso opportune modifiche ai file css che accompagnano 
			questo framework, abbiamo fatto in modo che la barra risultasse in alto 
			anche su Android in modo da rendere l'applicazione il più simile possibile 
			a quelle native.
			All'interno di questa barra abbiamo inserito il widget drawer, emulando 
			così la action bar e il navigation drawer di Android e la navbar di iOS,
			ottenendo appunto il sistema di navigazione desiderato (riferimento figura).
			Avendo utilizzato interamente i widget offerti da \kendomob{}, l'aspetto 
			della barra di navigazione viene adattato alla piattaforma senza 
			dover aggiungere nessuna riga di codice.
			
			\tisdk{} fornisce le API per creare direttamente la action bar nativa 
			di Android e la navbar nativa di iOS, però ancora non permette la 
			creazione del navigation drawer nativo di android, e dell'analogo 
			elemento su iOS. Però siamo comunque riusciti a fornire l'aspetto 
			desiderato all'applicazione.
			Con \tisdk{} infatti è comunque possibile disegnare elementi grafici 
			personalizzati ed assegnarli particolari comportamenti 
			semplicemente attraverso l'uso di xml, tss e \js{}. In particolare 
			avendo usato il framework alloy (descritto 
			nella sezione \ref{subsub:alloy}) abbiamo potuto usare un widget.
			Per Alloy un widget non è un semplice elemento grafico, ma un componente 
			con proprio view, controller e stile che può essere riutilizzato in progetti 
			diversi. Abbiamo così trovato in rete il widget \url{https://github.com/ricardoalcocer/alloy-widget-drawermenu/tree/master/app/widgets}
			che faceva esattamente al caso nostro. L'unica limitazione di questo 
			widget è che la barra d'intestazione con il menù è utilizzabile all'interno 
			di una sola window (dove comunque possono essere presenti più schermate 
			come detto attraverso le view) e inoltre funziona solo su iOS e Android.
			

		
		\subsection{Comunicare con il lato server}
			Sia con \tisdk{} che con \pg{} il linguaggio principalmente utilizzato,
			come abbiamo già detto, è \js{} e per questo motivo c'è stato il bisogno
			di realizzare una libreria fatta su misura che ci permettesse di generare
			i giusti messaggi HTTP da inviare al server. Ora, \tisdk{} ha la propria
			libreria \texttt{Titanium.Network} che permette di istanziare un
			particolare oggetto	\texttt{Titanium.Network.HTTPClient} con il
			quale è possibile comporre ogni genere di richiesta HTTP. \pg{}
			invece non fornisce nulla di tutto ciò e quindi abbiamo dovuto far
			ricorso alle funzionalità AJAX di \jq{} fornito dal framework
			\kendomob{}\footnote{Ricordiamo che \kendomob{}	è basato proprio su
			\jq{} e fornisce quindi tutte le sue funzionalità.}. Alla luce di
			questi fatti è stata definita un'unica interfaccia di funzioni \js{}
			e ne sono state realizzate due diverse implementazioni: una
			fruttando gli oggetti HTTPClient di \tisdk{} e l'altra basandoci
			sulla funzione \verb|$.ajax(...)| di \jq{}\footnote{Maggiori
			dettagli sull'uso di HTTPClinet e \texttt{\$.ajax(...)} sono
			disponibili nelle rispettive documentazioni online:\\
			\url{http://docs.appcelerator.com/titanium/latest/\#!/api/Titanium.Network.HTTPClient}
			e\\ \url{http://api.jquery.com/jQuery.ajax/}.}.
			È importante far notare
			che, sia HTTPClient che \verb|$.ajax(...)| implementano un sistema
			di comunicazione asincrono, ciò significa che una volta inviate le
			richieste HTTP, il programma continuerà ad essere eseguito in attesa
			che dal server tornino le relative risposte; a questo punto verrà
			eseguito l'opportuno codice che gestirà tale evento.
			
		\subsection{Registrazione al primo avvio}
			Come avevamo già anticipato, la prima cosa di cui deve occuparsi
			il client al suo primo avvio è quella di registrare un nuovo utente. Per
			poter distinguere ogni volta se l'applicazione è stata avviata 
			per la prima volta o meno c'è la
			necessità di avere qualche informazione in grado di permanere una volta
			che l'applicazione è stata chiusa.
			
			\pg{}, tramite il plugin
			\texttt{FileSystem}, offre la possibilità di accedere al file system
			del dispositivo così da poter creare ed	eliminare file; in questa
			situazione però è più comodo affidarsi al sistema di ``lo\-cal stor\-age''
			di \html{}5. In questo modo attraverso l'oggetto \js{} \texttt{localStorage}
			è possibile memorizzare, in maniera permanente tra varie sessioni, coppie
			chiave - valore di tipo \texttt{String - String}. Per esempio con il
			codice
			\begin{lstlisting}
	localStorage.setItem("name", "goofy");
	var n = localStorage.getItem("name");
	localStorage.removeItem("name");
			\end{lstlisting}
			si memorizza la coppia ``name'' - ``goofy'', si recupera la stringa associata
			alla chiave ``name'' e si elimina tale coppia definitivamente.
			
			La stessa funzionalità è presente anche in \tisdk{} offerta dal suo
			modulo \texttt{Titanium.App.Properties} che però, a differenza di
			quella standard di \html{}5, permette di memorizzare tutti i tipi di
			dato di \js{} tranne che funzioni. Facendo riferimento all'esempio 
			precedente, la stessa cosa è realizzabile con \tisdk mediante il
			codice
			\begin{lstlisting}
	Titanium.App.Properties.setString("name", "goofy");
	var n = Titanium.App.Properties.getString("name");
	Titanium.App.Properties.removeProperty("name");
			\end{lstlisting}

			La differenza sostanziale tra i due sistemi di memorizzazione risiede 
			nella quantità di dati che possono essere salvati. 
			Le specifiche di \html{}5 suggeriscono un limite di 5MB, ma la dimensione 
			può variare tra le varie piattaforme; mentre come afferma la documentazione 
			di \tisdk{} non c'è un limite specifico alla quantità di dati memorizzabili
			in Properties, bisogna però notare che questi dati sono caricati in 
			memoria principale quando 
			viene lanciata l'applicazione, e vi rimangono fino alla sua chiusura.
			Questo permette un rapido accesso ai dati, ma al costo di un aumento 
			della memoria usata dall'applicazione. 
			
			Dal punto di vista dello sviluppo cross platform \tisdk{} assicura il funzionamento 
			del sistema di memorizzazione descritto, direttamente senza dover riadattare il codice,
			su tutte le piattaforme supportate. Anche il local storage 
			di \html{}5 può essere usato per memorizzare dati su piattaforme diverse 
			usando lo stesso codice, ma il fatto di incorrere in diversi limiti di quota, 
			a seconda del sistema operativo, rende necessario un controllo più 
			accurato. Inoltre con \pg{} bisogna tenere conto che la web view di 
			alcune piattaforme potrebbe non supportare il local storage di \html{}5 
			(attualmente i principali OS Android, Windows Phone 8 e iOS lo fanno).
			
			Come descritto più volte, la registrazione doveva avvenire utilizzando 
			come credenziali il codice IMEI del disositivo oppure il numero di telefono.
			Nè con \pg{} nè con \tisdk{} questo è stato possibile. Nativamente 
			Android permette di accedere al codice IMEI, mentre iOS no; è stato 
			comunque possibile ottenere un identificatore con entrambi i 
			framework. \pg{} tramite il plugin \texttt{device} permette di accedere 
			ad alcune informazioni sul dispositivo come lo UUID, allo stesso 
			modo \tisdk{} fornisce una funzione per ottenere lo stesso UUID.
			Dobbiamo però fare una distinzione particolare sul valore di questo 
			UUID tra Android e iOS. 
			Le documentazioni di entrambi i framework affermano che date le limitazioni 
			imposte da iOS non è possibile ottenere un valore in grado di identificare 
			univocamente il dispositivo\footnote{Approfondimenti sulle limitazioni 
			imposte da iOS si trovano su \url{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDevice_Class/DeprecationAppendix/AppendixADeprecatedAPI.html\#//apple_ref/occ/instp/UIDevice/uniqueIdentifier}}. 
			Pertanto \pg{} e \tisdk{} hanno assegnato a UUID su questa piattaforma 
			un valore che identifica l'applicazione che però potrebbe essere diverso 
			dopo una reinstallazione o dopo 
			un aggiornamento della stessa o addirittura del sistema operativo. 
			Su Android invece UUID 
			identifica proprio il dispositivo. La conseguenza di tutto ciò è che 
			UUID non è affidabile per iOS e quindi sarebbe stato necessario utilizzare 
			un meccanismo di registrazione basato su credenziali differenti; 
			dato che però come detto l'applicazione è stata sviluppata solo per Android 
			abbiamo ritenuto opportuno prendere nota della differenza, ma abbiamo 
			continuato ad usare UUID.
		\subsection{La mappa delle segnalazioni}
			Arricchire la propria applicazione Titanium o \pg{} con una mappa
			non è un problema. Google fornisce un ricco insieme di API \js{} per
			l'utilizzo delle proprie mappe che quindi possiamo utilizzare nella
			web view di \pg{}. \tisdk, invece, inizialmente forniva l'oggetto
			\texttt{Titanium.Map} che permetteva di utilizzare le mappe su tutte
			le sue piattaforme supportate ma, dalla versione 3.2.0 dell'SDK, l'uso
			di queste API per Andorid e iOS è stato deprecato; ora, al suo posto,
			Titanium fornisce un implementazione più aggiornata con	il modulo
			gratuito \texttt{Module.Map}.
			
			Inserire la mappa nella nostra applicazione \pg{} è stato semplice:
			come mostrato nel segmento di codice seguente
			\begin{lstlisting}
	<div data-role="view"  data-title="Degrado Ambientale" id="map-view" data-layout="default" data-stretch="true" data-init="app.initMap" data-show="app.viewMapShow">
		<div id="map" style="width:100%;"></div>
	</div>
			\end{lstlisting}
			sfruttando il framework \kendomob{}, abbiamo definito una specifica
			view con all'interno un particolare elemento \texttt{div}; in fase di
			avvio dell'applicazione, tramite \js{}, abbiamo configurato e
			successivamente inizializzato la mappa su quel \texttt{div} (come
			mostrato nel frammento di codice \ref{cod:initmapPG}) così
			da renderla visibile all'utente all'interno di quella view come
			mostrato nella figura \ref{fig:mapPG}.
			\begin{lstlisting}[
				caption={
				    L'elemento \texttt{div} è stato selezionato mediante una
				    query \jq{} e su quello si è istanziata la mappa tramite
				    le API offerte da Google.
				},
				label={cod:initmapPG}
			]
	/** elemento <div> nel DOM che conterra' la mappa */
	var mapElement = $("#map")[0];

	/** configurazione della mappa */
	var mapOptions = {
		center: new google.maps.LatLng(43.720741,10.408413),
		zoom: 10
	};

	/** istanzia la mappa */
	app.map = new google.maps.Map(mapElement, mapOptions);
			\end{lstlisting}
			La mappa così implementata possiede tutte le caratteristiche offerte
			dalle mappe Google, in particolare, la possibilità di ottenere le
			coordinate dei punti in basso a sinistra e in alto a destra che
			delimitano l'area rettangolare mostrata e, la possibilità di
			disegnare dei segnaposto cliccabili con icone personalizzabili.
			Sfruttando queste funzionalità, una volta ottenute dal database
			tutte le segnalazioni riguardanti l'area attualmente visualizzata, è
			stato sufficiente creare un vettore di \texttt{google.maps.Marker} e
			passarlo alla mappa per	veder apparire tutte le segnalazioni sopra
			di essa. Un problema che però ci siamo trovati ad affrontare è stato
			il fatto che lo spostare la mappa verso destra entrava in conflitto
			con il gesto di swipe per l'apertura del menù. \kendomob{} non
			fornendo la possibilità di configurare la sensibilità dello swipe ci
			ha costretti a dover rinunciare all'uso di tale gesto per l'apertura
			e chiusura del drawer. Un altro appunto che dobbiamo fare riguarda
			le prestazioni: rispetto alle mappe che si possono trovare in
			applicazioni native, questa risulta essere molto meno fluida durante
			il suo trascinamento e durante il cambio del livello di zoom.
			\begin{figure}[h]
				\centering
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=\textwidth]{mapPG}
					\caption{}
					\label{fig:mapPG}
				\end{subfigure}
				~
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=\textwidth]{mapPGMark}
					\caption{}
					\label{fig:mapPGMark}
				\end{subfigure}
				\caption{
					Mappe ottenute mediante le API Google all'interno di
					view \kendomob{}. In (a) una normale mappa, in
					(b) una mappa con l'aggiunta di alcuni
					segnaposto personalizzati.
				}
				\label{fig:PGMaps}
			\end{figure}
			
			Anche per quanto riguarda l'uso delle mappe in progetti Titanium
			non comporta grandi difficoltà, in più il paradigma MVC
			offerto da Alloy rende tutto più modulare e strutturato.
			

