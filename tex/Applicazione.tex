\chapter{L'Applicazione}
	Per avere un confronto più significativo, il tutore aziendale ci ha proposto
	la realizzazione di un'applicazione che interagisse, in maniera sostanziale,
	con le funzionalità offerte dal dispositivo in modo da poter valutare meglio
	la potenzialità delle API offerte dai due frame\-work in analisi.
	
	L'applicazione che ci è stata commissionata permette all'utente di segnalare 
	problemi di degrado ambientale con immagini e testo georeferenziati.
	In particolare l'applicazione inizialmente doveva permette all'utente di:
	\begin{itemize}
		\item registrarsi nel sistema al primo avvio e di autenticarsi in quelli
		      successivi;
		\item visualizzare su una mappa le proprie segnalazioni e quelle inviate
		      degli altri utenti;
		\item comporre e inviare su un server una nuova segnalazione
		      georeferenziata inserendo una descrizione testuale e una foto del
		      degrado scattata con il dispositivo;
		\item visualizzare una lista riassuntiva delle proprie segnalazioni
		      inviate;
		\item scegliere una segnalazione e visualizzarne i dettagli.
	\end{itemize}
	Durante la fase di sviluppo però, in occasione della revisione periodica del
	nostro lavoro svolto, sono state richieste nuove funzionalità aggiuntive; in
	particolare ci è stato chiesto di aggiungere:
	\begin{itemize}
		\item una lista generale che mostrasse le ultime segnalazioni inviate da
		      qualsiasi utente;
		\item un meccanismo di salvataggio locale delle proprie segnalazioni e
		      di tutte quelle visualizzate in dettaglio permettendo così
		      all'applicazione un parziale funzionamento anche in assenza di
		      connessione Internet;
		\item la possibilità di ritrovare sulla mappa una segnalazione partendo
		      dalla visualizzazione dei suoi dettagli.
	\end{itemize}
	
	\noindent La registrazione e l'autenticazione dell'utente sul server doveva avvenire 
	utilizzando come credenziali di accesso il codice IMEI o il numero di
	telefono, che dovevano essere letti automaticamente dall'applicazione,
	senza necessità d'interazione con l'utente. Abbiamo però deciso, inoltre, di
	dare all'utente che si sta registrando la possibilità di scegliersi un
	``nickname'' univoco\footnote{Il controllo dell'univocità è stato demandato
	al lato server e verrà descritto più in dettaglio nella sezione apposita.}
	e di inserire il proprio indirizzo e-mail con l'idea di aggiungere,
	successivamente, queste informazioni in tutte le sue segnalazioni; in questo
	modo un altro utente che visualizza una certa segnalazione può vedere chi
	l'ha realizzata e, se vuole, sarà in grado di contattarlo tramite posta
	elettronica. Per semplicità abbiamo deciso che una volta scelto il nickname
	questo sarà permanente, diversamente abbiamo aggiunto nell'applicazione una
	schermata tramite la quale sarà possibile aggiornare il proprio indirizzo
	e-mail.
	
	L'applicazione, come ovvio, sarà composta di una parte client e di una parte
	server. Il lato client, che risiederà sul dispositivo mobile, è la parte dove
	si concentrano i nostri studi e dove
	mostreremo come sono state implementate le funzionalità richieste
	utilizzando i due frame\-work presi in esame. Il lato server risiederà
	su una macchina dedicata e per quanto riguarda la sua analisi, non
	essendo scopo di questa attività di tirocinio, ne daremo solo una
	semplice descrizione sul funzionamento e sulle tecnologie
	impiegate per realizzarlo.
	
	\section{Lato Server}
		Lo scopo principale del lato server di questa applicazione è quello di
		gestire un database che andrà a contenere tutte le segnalazioni inviate
		dagli utenti attraverso il dispositivo mobile. Il
		database dovrà essere in grado di rispondere a query riguardanti
		certamente le coordinate geografiche, ma anche i nickname e la data e
		ora delle varie segnalazioni. Un secondo compito importante che dovrà
		svolgere, sarà quello di gestire le identità dei diversi utenti e di
		controllare l'univocità del nickname utilizzato in fase di
		registrazione.
		
		Una caratteristica in più che non era richiesta ma che ci sembrava
		opportuno avere era l'indipendenza della realizzazione del server
		rispetto ai due frame\-work utilizzati nell'implementare il lato client.
		In questo modo entrambe le implementazioni del lato client avrebbero
		dialogato con la stessa implementazione del lato server.
		
		Per la realizzazione di tutto questo, dopo una fase di ricerca, abbiamo
		mirato a due prodotti open source vista la loro semplicità d'uso:
		Apache CouchDB\texttrademark{} e Node.js.
		\begin{description}
			\item[Apache CouchDB\texttrademark{}] è un DBMS (database-management
				system) doc\-u\-ment-ori\-ented accessibile mediante API RESTful\footnote{Il termine è usato
				per descrivere un'interfaccia che trasmette dati su HTTP. Per una
				descrizione più esaustiva vedere
				\url{http://it.wikipedia.org/wiki/Representational_State_Transfer}}
				con scambio di dati in formato \js{} Object Notation (JSON). Questa
				caratteristica permette di eseguire facilmente operazioni sul database
				indipendentemente dal linguaggio usato per realizzare l'applicazione.
				
				Un database document-oriented è composto da una serie di documenti
				``auto-contenenti'', questo significa che il documento in
				questione è memorizzato nel documento stesso anziché in una tabella
				come avviene nei database relazionali. Infatti in Apache CouchDB\texttrademark{}
				non esistono tabelle, righe, colonne e relazioni tra i
				documenti e quindi aggiungere o rimuovere un nuovo
				campo ad un documento non influisce negativamente sugli altri.
				
				Ogni documento è rappresentato in una struttura JSON che può
				contenere tipi di dato, come stringhe di testo, numeri e valori
				booleani; inoltre Apache CouchDB\texttrademark{} permette
				di allegare file multimediali ad ogni documento quindi nella sua
				definizione JSON sarà presente anche un riferimento a tale allegato. 
				Questa caratteristica ci ha permesso di inserire sia l'immagine che
				i dati di una segnalazione all'interno di un singolo documento.
				
				Nella sua versione pura, CouchDB non permette di eseguire interrogazioni 
				spaziali basate su coordinate geografiche, per sopperire a questa
				mancanza si è dovuto ricorrere all'utilizzo dell'apposita estensione
				GeoCouch\footnote{La documentazione 
				è disponibile sul sito \url{https://github.com/couchbase/geocouch/}}.
			\item[Node.js] è una piattaforma realizzata sul motore \js{} V8 di
				Google Chrome per la realizzazione facile e veloce di
				applicazioni di rete. La potenza di questa piattaforma è anche
				nel fatto che è supportata da una enorme quantità di moduli
				che permettono di realizzare con poco codice applicazioni piuttosto
				complesse; in più, come Apache CouchDB\texttrademark{}, tutto 
				questo è open source. Node.js è stato usato per creare un
				semplice web server che, comunicando col database Apache CouchDB\texttrademark{}
				attraverso le proprie API HTTP, gestisse le richieste di
				registrazione provenienti da nuovi utenti.
		\end{description}
		
		\noindent Apache CouchDB\texttrademark{} è stato quindi configurato per gestire e
		memorizzare l'insieme degli utenti e delle segnalazioni.
		Ogni documento rappresentante una segnalazione è composto dai campi:
		\begin{description}
			\item[Titolo] Stringa di poche parole per descrivere la segnalazione.
				Questo valore verrà poi visualizzato nelle liste di segnalazioni
				sul lato client.
			\item[Descrizione] Una descrizione testuale più dettagliata sul
				fenomeno di degrado segnalato. Questo valore verrà mostrato sul
				lato client solo tra i dettagli di una segnalazione.
			\item[Data] Stringa testuale che indica la data e l'ora dell'istante
				in cui la segnalazione è stata creata dall'utente. Anche questo
				valore sarà mostrato solo tra i dettagli.
			\item[Coordinate] Valore composto da due campi che contengono la
				latitudine nord e la longitudine est della posizione geografica
				in cui l'utente di trovava quando ha creato la segnalazione. Anche
				la posizione geografica verrà mostrata solo tra i dettagli della
				segnalazione.
			\item[Immagine] Una foto scattata dal dispositivo usata	per
				documentare il degrado individuato che verrà mostrata all'utente
				solo nella schermata dei dettagli della relativa segnalazione.
			\item[UserId] Identificatore unico relativo all'utente che ha creato
				questa segnalazione. Questo valore è necessario visto che in
				Apache CouchDB\texttrademark{}, non essendo un database relazionale,
				non è possibile in alcun altro modo mettere in relazione un utente con
				tutte le sue segnalazioni. Con questo accorgimento si sta di fatto
				creando tale relazione in modo che, una volta scaricate le
				informazioni su una segnalazione, sarà possibile eseguire una
				seconda query sul database degli utenti per ottenere i valori
				di nickname e mail dell'utente che ha creato quella segnalazione.
			\item[Id] Questo valore è univoco ed è scelto automaticamente da
				Apache CouchDB\texttrademark{}, nel momento del
				salvataggio della segnalazione sul server.
		\end{description}
		
		\noindent Per quanto riguarda la rappresentazione di un utente bisogna approfondire
		un po' più l'argomento. Apache CouchDB\texttrademark{} fornisce un
		particolare database di nome \verb|_users| in cui, ogni documento 
		rappresenta un utente e deve contenere i campi \texttt{name} e \texttt{password}, i cui
		rispettivi valori saranno poi utilizzati come credenziali di
		autenticazione da inserire nelle richieste HTTP per consentire
		all'utente operazioni sui DB contenuti nel server\footnote{
		Apache CouchDB\texttrademark{} permette una gestione delle utenze molto
		più accurata; per esempio è possibile riservare l'accesso ad un DB ad un
		particolare gruppo di utenti.}. Oltre ai suddetti campi obbligatori è
		possibile definirne altri pubblici, ovvero campi che al contrario di
		\texttt{name} e \texttt{password} saranno visibili a qualsiasi altro utente.
		Nel nostro caso abbiamo inserito solo due nuovi campi pubblici:
		\begin{description}
			\item[nickname] Un nome identificativo scelto dall'utente in fase di
				registrazione e mostrato poi nei dettagli di tutte le sue segnalazioni.
			\item[mail] Indirizzo di posta elettronica dell'utente mostrato anche questo
				nei dettagli di tutte le sue segnalazioni.
		\end{description}
		
		\noindent L'aggiunta di nuovi utenti nel database \verb|_users| deve essere fatta
		attraverso opportuni messaggi HTTP nei quali occorre essere autenticati
		come amministratori del server\footnote{Questo particolare utente viene
		definito in fase di configurazione del server Apache CouchDB\texttrademark{}}.
		Nasce qui il problema di come far registrare sul server nuovi utenti
		direttamente dal lato client dell'applicazione. Potevamo, a questo punto,
		scegliere d'inserire nel codice del lato client le credenziali
		d'amministratore usandole soltanto nelle richieste HTTP per la registrazione
		di un nuovo utente.	Successivamente il dispositivo mobile avrebbe continuato a
		comunicare con il server usando le credenziali del nuovo utente. Ovviamente
		questa soluzione avrebbe permesso a chiunque avesse accesso al codice
		sorgente dell'applicazione di ottenere nome utente e password dell'amministratore.
		Abbiamo quindi deciso di realizzare un semplice web server implementato
		con Node.js che lavori a fianco di Apache CouchDB\texttrademark{}
		(vedi fig.~\ref{fig:latoserver}) con il
		compito: di ascoltare richieste di registrazione provenienti dal lato
		client, di inoltrarle al DBMS aggiungendovi le credenziali di amministratore
		e di controllare che il \texttt{nickname} scelto dall'utente non sia già
		stato usato da un altro. Così facendo le credenziali di amministratore
		del DBMS sono contenute all'interno del web server Node.js e non sono più
		reperibili direttamente dal codice del lato client. 
		
		\begin{figure}[h]
			\centering
			\includegraphics[keepaspectratio=true, width=0.95\textwidth]{lato-server}
			\caption{
				Architettura del lato server dell'applicazione.
			}
			\label{fig:latoserver}
		\end{figure}
		
		Fin ora abbiamo detto che nelle varie richieste HTTP devo essere presenti
		le credenziali di autenticazione. Apache CouchDB\texttrademark{} fornisce
		vari meccanismi di autenticazione tra cui Basic Access Authentication\footnote{
		Schema di autenticazione definito per HTTP nella RFC2617 consultabile al'indirizzo
		\url{https://tools.ietf.org/html/rfc2617\#section-2}.}
		che abbiamo scelto di utilizzare per la sua semplicità. In questo modo il
		passaggio delle credenziali di accesso da client a server avviene attraverso 
		il campo header \texttt{Authorization} inserito nel messaggio di richiesta HTTP 
		come nell'esempio 
		\begin{lstlisting}[language=http]
	GET index.html HTTP/1.1
	Host: www.someserver.com
	Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQK
	 ...
		\end{lstlisting}
		dove \texttt{dXNlcm5hbWU6cGFzc3dvcmQK} è la stringa ``name:password'' 
		codificata in base64\footnote{Per una completa specifica del sistema di
		codifica/decodifica base64 consultare la RFC4648 disponibili all'indirizzo
		\url{http://www.rfc-editor.org/pdfrfc/rfc4648.txt.pdf}}.
		Questo tipo di autenticazione non prevede protezione per le credenziali 
		trasmesse; come visto esse vengono banalmente codificate in base64 ma non 
		criptate. Per cui l'uso di questo tipo di 
		autenticazione andrebbe fatto assieme ad un sistema di sicurezza esterno 
		come SSL\citep{Web:RFC2617}. CouchDB permette l'uso del protocollo HTTPS, 
		che però non abbiamo adottato dato che lo scopo del tirocinio non era quello di focalizzarsi 
		sulla sicurezza.
	
	
	\section{Lato Client}
		In questa sezione prenderemo in esame le varie funzionalità fornite
		dall'applicazione come pretesto per mostrare come si sono
		comportati i due framework. Non ci addentreremo
		nei dettagli di carattere algoritmico nelle soluzioni dei vari problemi ma,
		piuttosto, mostreremo quali strumenti ci hanno fornito \tisdk{} e \pg{}
		per poterli risolvere.
		
		\subsection{Struttura}
			Descriviamo ora la struttura generale dell'applicazione dal punto 
			di vista grafico.
			Abbiamo cercato di fornire lo stesso aspetto alle due versioni 
			dell'applicazione. E' interessante vedere come i due framework hanno risposto 
			alle nostre esigenze. Prendendo spunto da applicazioni native come 
			gmail e facebook l'idea è stata quella di avere una barra di intestazione, 
			nella parte alta dello schermo, che contenesse un pulsante in grado di 
			far apparire un menù dal quale accedere alle varie schermate dell'applicazione.
			Viste le funzionalità richieste dall'applicazione abbiamo creato schermate 
			differenti per:
			\begin{enumerate} 
				\item visualizzare la mappa delle segnalazioni 
				\item visualizzare la lista delle segnalazioni fatte dall'utente
				\item visualizzare la lista delle ultime segnalazioni fatte da tutti gli utenti
				\item comporre ed inviare la segnalazione
				\item effettuare la registrazione e/o modificare l'indirizzo mail registrato.
				\item visualizzare i dettagli di una segnalazione
			\end{enumerate}
			
			I due framework approcciano in maniera differente il concetto di schermata: 
			in \kendomob{} le schermate vanno inserite nel body dello stesso 
			file HTML, tramite div decorati con l'attributo data-role=view, la 
			navigazione tra di esse avviene attraverso le ancore come nelle normali 
			pagine web si naviga all'interno dello stesso documento; Titanium invece 
			permette due modi diversi di definire una schermata: la view e la window.
			Una view deve essere necessariamente contenuta in una window, nel linguaggio 
			del web una window Titanium è paragonabile ad una pagina web. Mentre le view 
			sono analoghe ai div. Un'applicazione potrebbe essere costituita da un'unica 
			window con tante view (che sarebbe la stessa tecnica usata con \kendomob{}) 
			dando l'effetto appunto di essere composta da schermate differenti, oppure 
			può essere composta da tante window. La differenza si ha nel fatto che 
			le window hanno contesti di esecuzione diversi l'una dall'altra al contrario 
			delle view che condividono quello della window che le contiene.
			Personalmente abbiamo scelto di implementare le schermate 1, 2, 3 come 
			view appartenenti alla stessa window e le 4, 5, 6 come window differenti, 
			questo ha facilitato la navigazione tra le varie schermate, in quanto 
			il passaggio da una view all'altra non è così semplice in \tisdk{} come 
			lo è invece in \kendomob{}.
			
			Per la barra di intestazione ed il menù di navigazione abbiamo trovato 
			differenze sostanziali tra i due framework.
			Partiamo con \kendomob{}
			Innanzitutto esso offre un particolare elemento grafico chiamato drawer, 
			ovvero un bottone che se premuto porta all'apertura di 
			una lista che si espande partendo dalla sinistra dello schermo e che 
			si va a sovrapporre al contenuto della schermata stessa.
			Ogni schermata può essere suddivisa in un intestazione e un corpo, 
			con l'effetto che l'intestazione apparirà come una barra nella parte alta 
			dello schermo. Per essere più precisi la sua posizione dipende dalla
			piattaforma: di default su iOS la posizione è in alto, mentre per Android 
			è in basso, ma, attraverso opportune modifiche ai file css che accompagnano 
			questo framework, abbiamo fatto in modo che la barra risultasse in alto 
			anche su Android in modo da rendere l'applicazione il più simile possibile 
			a quelle native.
			All'interno di questa barra abbiamo inserito il widget drawer, emulando 
			così la action bar e il navigation drawer di Android e la navbar di iOS,
			ottenendo appunto il sistema di navigazione desiderato (vedi fig.\ref{fig:kendodrawer}).
			Avendo utilizzato interamente i widget offerti da \kendomob{}, l'aspetto 
			della barra di navigazione viene adattato alla piattaforma senza 
			dover aggiungere nessuna riga di codice.
			\begin{figure}[h]
				\centering
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=0.95\textwidth]{KendoDrawerClose}
					\caption{}
					\label{fig:kendoDrawerClose}
				\end{subfigure}
				~
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=0.95\textwidth]{KendoDrawerOpen}
					\caption{}
					\label{fig:kendoDrawerOpen}
				\end{subfigure}
				\caption{Schermata iniziale dell'applicazione con \kendomob{}. 
				In (a) si vede la barra di intestazione con il pulsante drawer 
				per aprire il menù di navigazione, in (b) si mostra il menù aperto 
				e l'effetto che ha sulla schermata}
				\label{fig:kendodrawer}
			\end{figure}
		
			\tisdk{} fornisce le API per creare direttamente la action bar nativa 
			di Android e la navbar nativa di iOS, però ancora non permette la 
			creazione del navigation drawer di Android, e dell'analogo 
			elemento su iOS. Siamo comunque riusciti a fornire l'aspetto 
			desiderato all'applicazione.
			Con \tisdk{} infatti è possibile disegnare elementi grafici 
			personalizzati ed assegnarli particolari comportamenti 
			semplicemente attraverso l'uso di xml, tss e \js{}. Nel framwork Alloy 
			(descritto nella sezione \ref{subsub:alloy}) questi elementi sono 
			chiamati widget e possono essere creati in un progetto per poi essere 
			utilizzati anche in altri, questa caratteristica ha permesso la nascita 
			di numerosi widget creati 
			da sviluppatori indipendenti. 
			Abbiamo così trovato in rete il widget \url{https://github.com/ricardoalcocer/alloy-widget-drawermenu/tree/master/app/widgets}
			contenente tutti gli elementi necessari per fornire all'applicazione 
			l'aspetto dato con \kendomob{} (vedi fig. \ref{fig:tidrawer}). 
			Il widget aveva dei propri colori e icone, ma modificando i file 
			opportuni lo abbiamo adattato alle nostre esigenze.
			Questo widget funziona sia per iOS che per Android, ma il suo aspetto 
			non si adatta automaticamente alla piattaforma, teoricamente è possibile
			modificarlo per aggiungervi anche questa funzionalità, avendo però 
			la possibilità di testare l'applicazione solo su dispositivi Android non 
			ci siamo addentrati in tale modifica.
			
			\begin{figure}[h]
				\centering
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=0.95\textwidth]{TiDrawerClose}
					\caption{}
					\label{fig:tiDrawerClose}
				\end{subfigure}
				~
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=0.95\textwidth]{TiDrawerOpen}
					\caption{}
					\label{fig:tiDrawerOpen}
				\end{subfigure}
				\caption{Schermata iniziale dell'applicazione con \tisdk{}. 
				In (a) si vede la barra di intestazione con il pulsante drawer per aprire 
				il menù di navigazione, in (b) si mostra il menù aperto 
				e l'effetto che ha sulla schermata.}
				\label{fig:tidrawer}
			\end{figure}
			
			
		\subsection{Comunicare con il lato server}
			Sia con \tisdk{} che con \pg{} il linguaggio principalmente utilizzato,
			come abbiamo già detto, è \js{} e per questo motivo c'è stato il bisogno
			di realizzare una libreria fatta su misura che ci permettesse di generare
			i giusti messaggi HTTP da inviare al server. Ora, \tisdk{} ha la propria
			libreria \texttt{Titanium.Network} che permette di istanziare un
			particolare oggetto	\texttt{Titanium.Network.HTTPClient} con il
			quale è possibile comporre ogni genere di richiesta HTTP. \pg{}
			invece non fornisce nulla di tutto ciò e quindi abbiamo dovuto far
			ricorso alle funzionalità AJAX di \jq{} fornito dal framework
			\kendomob{}\footnote{Ricordiamo che \kendomob{}	è basato proprio su
			\jq{} e fornisce quindi tutte le sue funzionalità.}. Alla luce di
			questi fatti è stata definita un'unica interfaccia di funzioni \js{}
			e ne sono state realizzate due diverse implementazioni: una
			fruttando gli oggetti HTTPClient di \tisdk{} e l'altra basandoci
			sulla funzione \verb|$.ajax(...)| di \jq{}\footnote{Maggiori
			dettagli sull'uso di HTTPClinet e \texttt{\$.ajax(...)} sono
			disponibili nelle rispettive documentazioni online:\\
			\url{http://docs.appcelerator.com/titanium/latest/\#!/api/Titanium.Network.HTTPClient}
			e\\ \url{http://api.jquery.com/jQuery.ajax/}.}.
			È importante far notare
			che, sia HTTPClient che \verb|$.ajax(...)| implementano un sistema
			di comunicazione asincrono, ciò significa che una volta inviate le
			richieste HTTP, il programma continuerà ad essere eseguito in attesa
			che dal server tornino le relative risposte; a questo punto verrà
			eseguito l'opportuno codice che gestirà tale evento.
			
			
		\subsection{Registrazione al primo avvio}
			Come avevamo già anticipato, la prima cosa di cui deve occuparsi
			il client al suo primo avvio è quella di registrare un nuovo utente. Per
			poter distinguere ogni volta se l'applicazione è stata avviata 
			per la prima volta o meno c'è la
			necessità di avere qualche informazione in grado di permanere una volta
			che l'applicazione è stata chiusa.
			
			\pg{}, tramite il plugin
			\texttt{FileSystem}, offre la possibilità di accedere al file system
			del dispositivo così da poter creare ed	eliminare file; in questa
			situazione però è più comodo affidarsi al sistema di ``lo\-cal stor\-age''
			di \html{}5. In questo modo attraverso l'oggetto \js{} \texttt{localStorage}
			è possibile memorizzare, in maniera permanente tra varie sessioni, coppie
			chiave - valore di tipo \texttt{String - String}. Per esempio con il
			codice
			\begin{lstlisting}
	localStorage.setItem("name", "goofy");
	var n = localStorage.getItem("name");
	localStorage.removeItem("name");
			\end{lstlisting}
			si memorizza la coppia ``name'' - ``goofy'', si recupera la stringa associata
			alla chiave ``name'' e si elimina tale coppia definitivamente.
			
			La stessa funzionalità è presente anche in \tisdk{} offerta dal suo
			modulo \texttt{Titanium.App.Properties} che però, a differenza di
			quella standard di \html{}5, permette di memorizzare tutti i tipi di
			dato di \js{} tranne che funzioni. Facendo riferimento all'esempio 
			precedente, la stessa cosa è realizzabile con \tisdk mediante il
			codice
			\begin{lstlisting}
	Titanium.App.Properties.setString("name", "goofy");
	var n = Titanium.App.Properties.getString("name");
	Titanium.App.Properties.removeProperty("name");
			\end{lstlisting}

			La differenza sostanziale tra i due sistemi di memorizzazione risiede 
			nella quantità di dati che possono essere salvati. 
			Le specifiche di \html{}5 suggeriscono un limite di 5MB, ma la dimensione 
			può variare tra le varie piattaforme; mentre come afferma la documentazione 
			di \tisdk{} non c'è un limite specifico alla quantità di dati memorizzabili
			in Properties, bisogna però notare che questi dati sono caricati in 
			memoria principale quando 
			viene lanciata l'applicazione, e vi rimangono fino alla sua chiusura.
			Questo permette un rapido accesso ai dati, ma al costo di un aumento 
			della memoria usata dall'applicazione. 
			
			Dal punto di vista dello sviluppo cross platform \tisdk{} assicura il funzionamento 
			del sistema di memorizzazione descritto, direttamente senza dover riadattare il codice,
			su tutte le piattaforme supportate. Anche il local storage 
			di \html{}5 può essere usato per memorizzare dati su piattaforme diverse 
			usando lo stesso codice, ma il fatto di incorrere in diversi limiti di quota, 
			a seconda del sistema operativo, rende necessario un controllo più 
			accurato. Inoltre con \pg{} bisogna tenere conto che la web view di 
			alcune piattaforme potrebbe non supportare il local storage di \html{}5 
			(attualmente i principali OS Android, Windows Phone 8 e iOS lo fanno).
			
			Come descritto più volte, la registrazione doveva avvenire utilizzando 
			come credenziali il codice IMEI del disositivo oppure il numero di telefono.
			Nè con \pg{} nè con \tisdk{} questo è stato possibile. Nativamente 
			Android permette di accedere al codice IMEI, mentre iOS no; è stato 
			comunque possibile ottenere un identificatore con entrambi i 
			framework. \pg{} tramite il plugin \texttt{device} permette di accedere 
			ad alcune informazioni sul dispositivo come lo UUID, allo stesso 
			modo \tisdk{} fornisce una funzione per ottenere lo stesso UUID.
			Dobbiamo però fare una distinzione particolare sul valore di questo 
			UUID tra Android e iOS. 
			Le documentazioni di entrambi i framework affermano che date le limitazioni 
			imposte da iOS non è possibile ottenere un valore in grado di identificare 
			univocamente il dispositivo\footnote{Approfondimenti sulle limitazioni 
			imposte da iOS si trovano su \url{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDevice_Class/DeprecationAppendix/AppendixADeprecatedAPI.html\#//apple_ref/occ/instp/UIDevice/uniqueIdentifier}}. 
			Pertanto \pg{} e \tisdk{} hanno assegnato a UUID su questa piattaforma 
			un valore che identifica l'applicazione che però potrebbe essere diverso 
			dopo una reinstallazione o dopo 
			un aggiornamento della stessa o addirittura del sistema operativo. 
			Su Android invece UUID 
			identifica proprio il dispositivo. La conseguenza di tutto ciò è che 
			UUID non è affidabile per iOS e quindi sarebbe stato necessario utilizzare 
			un meccanismo di registrazione basato su credenziali differenti; 
			dato che però come detto l'applicazione è stata sviluppata solo per Android 
			abbiamo ritenuto opportuno prendere nota della differenza, ma abbiamo 
			continuato ad usare UUID.
			
			
		\subsection{La mappa delle segnalazioni}
			Arricchire la propria applicazione Titanium o \pg{} con una mappa
			non è un problema. Google fornisce un ricco insieme di API \js{} per
			l'utilizzo delle proprie mappe che quindi possiamo utilizzare nella
			web view di \pg{}. \tisdk, invece, inizialmente forniva l'oggetto
			\texttt{Titanium.Map} che permetteva di utilizzare le mappe su tutte
			le sue piattaforme supportate ma, dalla versione 3.2.0 dell'SDK, l'uso
			di queste API per Andorid e iOS è stato deprecato; ora, al suo posto,
			Titanium fornisce un implementazione più aggiornata con	il modulo
			gratuito \texttt{ti.map}.
			
			Inserire la mappa nella nostra applicazione \pg{} è stato semplice:
			come mostrato nel segmento di codice seguente
			\begin{lstlisting}
	<div data-role="view" data-title="Degrado Ambientale"
	  id="map-view" data-layout="default"
	  data-stretch="true" data-init="app.initMap"
	  data-show="app.viewMapShow"
	>
		<div id="map" style="width:100%;"></div>
	</div>
			\end{lstlisting}
			sfruttando il framework \kendomob{}, abbiamo definito una specifica
			view con all'interno un particolare elemento \texttt{div}; in fase di
			avvio dell'applicazione, tramite \js{}, abbiamo configurato e
			successivamente inizializzato la mappa su quel \texttt{div} (come
			mostrato nel frammento di codice \ref{cod:initmapPG}) così
			da renderla visibile all'utente all'interno di quella view come
			mostrato nella figura \ref{fig:mapPG}.
			\begin{lstlisting}[
				caption={
				    L'elemento \texttt{div} è stato selezionato mediante una
				    query \jq{} e su quello si è istanziata la mappa tramite
				    le API offerte da Google.
				},
				label={cod:initmapPG}
			]
	/** elemento 'div' nel DOM che conterra' la mappa */
	var mapElement = $("#map")[0];

	/** configurazione della mappa */
	var mapOptions = {
		center: new google.maps.LatLng(43.720741,10.408413),
		zoom: 10
	};

	/** istanzia la mappa */
	app.map = new google.maps.Map(mapElement, mapOptions);
			\end{lstlisting}
			La mappa così implementata possiede tutte le caratteristiche offerte
			dalle mappe Google, in particolare, la possibilità di ottenere le
			coordinate dei punti in basso a sinistra e in alto a destra che
			delimitano l'area rettangolare mostrata e, la possibilità di
			disegnare dei segnaposto cliccabili con icone personalizzabili.
			Sfruttando queste funzionalità, una volta ottenute dal database
			tutte le segnalazioni riguardanti l'area attualmente visualizzata, è
			stato sufficiente creare un vettore di \texttt{google.maps.Marker} e
			passarlo alla mappa per	veder apparire tutte le segnalazioni sopra
			di essa. Un problema che però ci siamo trovati ad affrontare è stato
			il fatto che lo spostare la mappa verso destra entrava in conflitto
			con il gesto di swipe per l'apertura del menù. \kendomob{} non
			fornendo la possibilità di configurare la sensibilità dello swipe ci
			ha costretti a dover rinunciare all'uso di tale gesto per l'apertura
			e chiusura del drawer. Un altro appunto che dobbiamo fare riguarda
			le prestazioni: rispetto alle mappe che si possono trovare in
			applicazioni native, questa risulta essere molto meno fluida durante
			il suo trascinamento e durante il cambio del livello di zoom.
			\begin{figure}[h]
				\centering
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=\textwidth]{mapPG}
					\caption{}
					\label{fig:mapPG}
				\end{subfigure}
				~
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=\textwidth]{mapPGMark}
					\caption{}
					\label{fig:mapPGMark}
				\end{subfigure}
				\caption{
					Mappe ottenute mediante le API Google all'interno di
					view \kendomob{}. In (a) una normale mappa, in
					(b) una mappa con l'aggiunta di alcuni
					segnaposto personalizzati.
				}
				\label{fig:PGMaps}
			\end{figure}
			
			Anche per quanto riguarda l'uso delle mappe in progetti Titanium
			non comporta grandi difficoltà, in più il paradigma MVC
			offerto da Alloy rende tutto più modulare e strutturato. Per ottenere
			una view con al suo interno la mappa bisogna prima caricare il modulo
			relativo, questo lo si fa tipicamente all'interno del file
			\texttt{app/alloy.js} così che il caricamento del modulo venga
			eseguito immediatamente dopo l'avvio dell'applicazione; in più è cosa
			comune creare il riferimento nello spazio dei nomi \texttt{Alloy.Globals}
			in modo da essere reperibile da ogni punto del progetto (vedi codice \ref{cod:alloyglob}).
			\begin{lstlisting}[
				caption={Caricamento del modulo \texttt{ti.map} creando un riferimento
				        globale nel file \texttt{alloy.js}.},
				label=cod:alloyglob
			]
	// caricamento modulo mappa
	Alloy.Globals.Map = require('ti.map');
			\end{lstlisting}
			Fatto questo abbiamo definito la view in un file XML dedicato, vi abbiamo richiamato
			il modulo per la mappa (vedi codice \ref{cod:alloymapview}) e, in un secondo file \js{} specifico per
			l'implementazione del controllore, sono stati definiti tutti i
			gestori per gli eventi (per noi interessanti da gestire) che la
			mappa potrà scatenare durante l'interazione con l'utente (vedi codice \ref{cod:alloymapcontroller}).
			\begin{lstlisting}[
				caption={Contenuto del file \texttt{map.xml} che definisce la
				view contenente la mappa.},
				label=cod:alloymapview
			]
	<Alloy>
		<View
			id="map" ns="Alloy.Globals.Map" regionFit="true"
			onClick="markerClick"
			onRegionchanged="moved"
			onComplete="mapCompleted"/>
	</Alloy>
			\end{lstlisting}
			\begin{lstlisting}[
				caption={Parte del file \texttt{map.js}, controllore per la mappa, con le definizioni dei gestori per
				gli eventi di ``spostamento mappa'', ``click sulla mappa'' e ``caricamento completato''},
				label=cod:alloymapcontroller
			]

	[...]

	/**
	 * Handler del click su un segnaposto della mappa.
	 * @param {ModulesMapViewEvent} evt evento passato allo
	 *   handler al momento della chiamata.
	 */
	function markerClick(evt) {	...	}

	/**
	 * handler dell'evento associato allo spostamento e
	 * ridimensionamento della mappa.
	 * @param {ModulesMapViewEvent} evt evento passato allo
	 *   handler al momento della chiamata.
	 */
	function moved(evt) { ... }

	/**
	 * Handler dell'evento onComplete scatenato appena la mappa
	 * e' pronta.
	 *
	 * Recupera la posizione corrente e una volta ottenuta
	 * inizializza la mappa con quella posizione.
	 *
	 * @param {ModulesMapViewEvent} evt
	 */
	function mapCompleted(evt){ ... }

			\end{lstlisting}
			Come visto nel caso dell'applicazione \pg{} è possibile, anche qui,
			disegnare segnaposto sulla mappa e reperire le informazioni
			necessarie alla composizione delle query spaziali per scaricare le
			segnalazioni da mostrare (vedi fig. \ref{fig:TiMaps}). Il modulo
			\texttt{ti.map} fornisce sostanzialmente un'interfaccia che permette
			tramite \js{} l'uso	delle rispettive mappe native per le piattaforme
			iOS e Android. Le mappe risultati sono notevolmente più performanti
			rispetto a quelle descritte precedentemente fornendo un esperienza
			utente molto più gradevole.
			\begin{figure}[h]
				\centering
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=\textwidth]{tiMap}
					\caption{}
					\label{fig:tiMap}
				\end{subfigure}
				~
				\begin{subfigure}[b]{0.485\textwidth}
					\includegraphics[keepaspectratio=true, width=\textwidth]{tiMapMark}
					\caption{}
					\label{fig:tiMapMark}
				\end{subfigure}
				\caption{
					Mappe ottenuto con il modulo \texttt{ti.map} su Android: (a)
					una normale mappa; (b) esempio di segnaposto personalizzati
					disegnati sulla mappa.
				}
				\label{fig:TiMaps}
			\end{figure}
			
			Dal punto di vista dello sviluppo \crossplat{}, l'uso delle mappe in
			applicazioni \pg{} non dà nessun problema non essendo necessario
			interagire con funzionalità del dispositivo; una volta scritto,
			tutto il codice sarà utilizzabile su tutte le piattaforme per le
			quali si sta sviluppando l'applicazione. Inoltre non si è
			costretti ad utilizzare soltanto il servizio mappe di Google, online
			sono disponibili altre API \js{} open source come Leaflet oppure
			di proprietà di marchi conosciuti come Bing (di Microsoft) o HERE
			(di Nokia). Per applicazioni \tisdk{} il discorso è un po' più
			delicato: per supportare sia la piattaforma Android che iOS sono
			sufficienti le API del modulo \texttt{ti.map} mentre per BlackBerry,
			Tizen e Web bisogna specializzare il codice per l'uso dell'oggetto
			\texttt{Titanium.Map}. Ad ogni modo abbiamo comunque la possibilità
			di rinunciare alle API delle mappe offerte da \tisdk{}: il codice
			\js{}/\html{} che utilizza le API online del nostro fornitore di
			mappe preferito, può essere caricato in un'opportuna web view,
			quest'ultima ottenuta attraverso le API di \tisdk{} che stavolta
			supportano tutte le piattaforme senza alcuna differenza.
			
			
		\subsection{Creare una nuova segnalazione}
			Creare una segnalazione sembra una cosa semplice ma per
			comporne una c'è bisogno di una sostanziale interazione con il
			dispositivo. Quello che andremo a descrivere ed a valutare sarà
			come \pg{} e \tisdk{} si sono comportati quando abbiamo avuto
			bisogno di:
			\begin{itemize}
				\item ottenere l'input testuale immesso dall'utente;
				\item interagire con la fotocamera del dispositivo per ottenere
					una foto del degrado da allegare;
				\item interagire con il servizio di geolocalizzazione per
					recuperare la posizione attuale del dispositivo.
			\end{itemize}
			
			\noindent Sul rilevare l'input immesso dall'utente non ci sono molte
			considerazioni da fare: sia \tisdk{} che
			\kendomob{}\footnote{Rilevare input testuale non compete \pg{}, non
			è un interazione con funzionalità del dispositivo; riguarda invece
			funzionalità dei widget di cui è comporta l'interfaccia grafica.}
			mettono a disposizione i propri widget di ``input'' per i quali sono
			definiti gli opportuni metodi per ottenere il valore immesso
			dall'utente.
			
			Accedere alla fotocamera per scattare ed acquisire una foto non è un 
			compito banale; \pg{} lo rende possibile attraverso le API del
			proprio plugin \texttt{Camera}. Tramite la funzione
			\texttt{getPicture} viene avviata l'applicazione nativa della
			fotocamera dove l'utente, una volta scattata la foto ha la
			possibilità di accettarla o di rifiutarla. Le azioni da
			intraprendere nei due casi sono specificate in due rispettive
			funzioni \js{} che vengono passate come parametri al momento della
			chiamata di	\texttt{getPicture}. Questa funzione accetta anche
			anche terzo parametro che specifica un certo numero di opzioni
			permettendo di modificare la foto acquisita; in particolare è
			possibile ridimensionare l'immagine, specificare la qualità della
			compressione JPEG utilizzata e indicare il formato dei dati
			restituiti dalla chiamata. \tisdk{} offre la stessa funzionalità di
			acquisire foto tramite la funzione \texttt{showCamera} dello spazio
			dei nomi \texttt{Titanium.Media}. La differenza con \pg{} è che i
			dati dell'immagine vengono restituiti solo in formato binario
			tramite un oggetto \js{} \texttt{Blob} così come vendono acquisiti;
			per modificare l'immagine si deve ricorrere ad altre funzionalità
			magari offerte anche da qualche modulo aggiuntivo\footnote{Appcelerator
			fornisce il modulo gratuito \texttt{ti.imagefactory} però
			disponibile solo per Android e iOS}.
			
			Recuperate le informazioni inserite dall'utente ed acquisita la
			fotografia c'è bisogno di recuperare le coordinate geografiche della
			posizione attuale. \pg{} consente di accedere al servizio di
			geolocalizzazione del dispositivo attraverso il plugin
			\texttt{Geolocation} che permette sia di monitorare in maniera
			continuativa la posizione, sia di inviare una sola richiesta per la
			posizione corrente. In entrambi i casi si possono passare dei
			parametri di opzione alle rispettive funzioni, per esempio, per
			ottenere la posizione esatta mediante il ricevitore GPS oppure,
			quella meno accurata, mediante il sistema si approssimazione che
			impiega le informazioni sulle reti WiFi presenti nella zone e la
			cella telefonica alla quale si è agganciati per stimare la
			posizione. In \tisdk{} si accede al sistema di
			geolocalizzazione attraverso le API del gruppo
			\texttt{Titanium.Geolocation} che oltre a mettere a disposizione i
			metodi per la richiesta (continua o meno) della posizione corrente,
			offrono anche il servizio di geocoding che da la possibilità di
			trasformare la posizione data in coordinate geografiche in un
			normale indirizzo postale. L'uso dei metodi per ottenere i dati
			sulla posizione è lo stesso per tutte le piattaforme che si possono
			supportare ma troviamo delle differenze sostanziali per quanto
			riguarda la configurazione del servizio, questo perché le diverse
			piattaforme ne danno una differente implementazione.
			
			Concludiamo facendo notare che al momento della realizzazione della
			nostra applicazione \pg{} ha mostrato qualche problema con
			l'attivazione del GPS: se si tentava di ottenere la posizione
			accurata, il GPS veniva attivato correttamente e disattivato una
			volta ottenuta la posizione ma, da quel momento in poi, il servizio
			veniva riavviato in modo casuale anche se l'applicazione era già
			stata terminata. Un altro dettaglio degno di nota è il comportamento
			del metodo \texttt{getCurrentPosition} di \tisdk{}: questo
			restituisce la posizione corrente ma, su Android, non attiva mai il
			ricevitore GPS e preleva le informazioni dalla cache del
			dispositivo; su iOS invece il GPS può essere attivato se il sistema
			valuta le informazioni in cache ``troppo vecchie'' e non più
			attendibili.
			
			
